From 62157c5e6218c5eee2eafeb7424b4937aca36a47 Mon Sep 17 00:00:00 2001
From: Kyle Anderson <kyle@xkyle.com>
Date: Sun, 24 Mar 2013 09:18:21 -0700
Subject: [PATCH] (#19877) Add support the openwrt service provider

OpenWrt has its own unique initscript conventions, as well as
its own support for enabling and disabling services. This commit
adds support for them and for being the default provider for
OpenWrt platforms.
---
 lib/puppet/provider/service/openwrt.rb     |   36 +++++++++
 spec/unit/provider/service/openwrt_spec.rb |  109 ++++++++++++++++++++++++++++
 2 files changed, 145 insertions(+)
 create mode 100644 lib/puppet/provider/service/openwrt.rb
 create mode 100755 spec/unit/provider/service/openwrt_spec.rb

diff --git a/lib/puppet/provider/service/openwrt.rb b/lib/puppet/provider/service/openwrt.rb
new file mode 100644
index 0000000..f117127
--- /dev/null
+++ b/lib/puppet/provider/service/openwrt.rb
@@ -0,0 +1,36 @@
+Puppet::Type.type(:service).provide :openwrt, :parent => :init, :source => :init do
+  desc <<-EOT
+    Support for OpenWrt flavored init scripts.
+
+    Uses /etc/init.d/service_name enable, disable, and enabled.
+
+  EOT
+
+  defaultfor :operatingsystem => :openwrt
+  confine :operatingsystem => :openwrt
+
+  has_feature :enableable
+
+  def self.defpath
+    ["/etc/init.d"]
+  end
+
+  def enable
+    system(self.initscript, 'enable')
+  end
+
+  def disable
+    system(self.initscript, 'disable')
+  end
+
+  def enabled?
+    # We can't define the "command" for the init script, so we call system?
+    if system(self.initscript, 'enabled') then return :true else return :false end
+  end
+
+  # Purposely leave blank so we fail back to ps based status detection
+  # As OpenWrt init script do not have status commands
+  def statuscmd
+  end
+
+end
diff --git a/spec/unit/provider/service/openwrt_spec.rb b/spec/unit/provider/service/openwrt_spec.rb
new file mode 100755
index 0000000..14f5e33
--- /dev/null
+++ b/spec/unit/provider/service/openwrt_spec.rb
@@ -0,0 +1,109 @@
+#! /usr/bin/env ruby
+#
+# Unit testing for the OpenWrt service Provider
+#
+require 'spec_helper'
+
+describe Puppet::Type.type(:service).provider(:openwrt), :as_platform => :posix do
+
+  let(:resource) do
+    resource = stub 'resource'
+    resource.stubs(:[]).returns(nil)
+    resource.stubs(:[]).with(:name).returns "myservice"
+    resource.stubs(:[]).with(:path).returns ["/etc/init.d"]
+
+    resource
+  end
+
+  subject(:provider) do
+    provider = described_class.new
+    provider.stubs(:get).with(:hasstatus).returns false
+
+    provider
+  end
+
+
+  before :each do
+    resource.stubs(:provider).returns provider
+    provider.resource = resource
+
+    FileTest.stubs(:file?).with('/etc/rc.common').returns true
+    FileTest.stubs(:executable?).with('/etc/rc.common').returns true
+
+    # All OpenWrt tests operate on the init script directly. It must exist.
+    File.stubs(:directory?).with('/etc/init.d').returns true
+
+    File.stubs(:stat).with('/etc/init.d/myservice')
+    FileTest.stubs(:file?).with('/etc/init.d/myservice').returns true
+    FileTest.stubs(:executable?).with('/etc/init.d/myservice').returns true
+  end
+
+  operatingsystem = 'openwrt'
+  it "should be the default provider on #{operatingsystem}" do
+    Facter.expects(:value).with(:operatingsystem).returns(operatingsystem)
+    described_class.default?.should be_true
+  end
+
+  # test self.instances
+  describe "when getting all service instances" do
+
+    let(:services) {['dnsmasq', 'dropbear', 'firewall', 'led', 'puppet', 'uhttpd' ]}
+
+    before :each do
+      Dir.stubs(:entries).returns services
+      FileTest.stubs(:directory?).returns(true)
+      FileTest.stubs(:executable?).returns(true)
+    end
+    it "should return instances for all services" do
+      services.each do |inst|
+        described_class.expects(:new).with{|hash| hash[:name] == inst && hash[:path] == '/etc/init.d'}.returns("#{inst}_instance")
+      end
+      results = services.collect {|x| "#{x}_instance"}
+      described_class.instances.should == results
+    end
+  end
+
+  it "should have an enabled? method" do
+    provider.should respond_to(:enabled?)
+  end
+
+  it "should have an enable method" do
+    provider.should respond_to(:enable)
+  end
+
+  it "should have a disable method" do
+    provider.should respond_to(:disable)
+  end
+
+  [:start, :stop, :restart].each do |method|
+    it "should have a #{method} method" do
+      provider.should respond_to(method)
+    end
+    describe "when running #{method}" do
+
+      it "should use any provided explicit command" do
+        resource.stubs(:[]).with(method).returns "/user/specified/command"
+        provider.expects(:execute).with { |command, *args| command == ["/user/specified/command"] }
+        provider.send(method)
+      end
+
+      it "should execute the init script with #{method} when no explicit command is provided" do
+        resource.stubs(:[]).with("has#{method}".intern).returns :true
+        provider.expects(:execute).with { |command, *args| command ==  ['/etc/init.d/myservice', method ]}
+        provider.send(method)
+      end
+    end
+  end
+
+  describe "when checking status" do
+    it "should consider the service :running if it has a pid" do
+      provider.expects(:getpid).returns "1234"
+      provider.status.should == :running
+    end
+    it "should consider the service :stopped if it doesn't have a pid" do
+      provider.expects(:getpid).returns nil
+      provider.status.should == :stopped
+    end
+  end
+
+end
-- 
1.7.10.4

